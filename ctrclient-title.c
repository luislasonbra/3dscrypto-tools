#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>

#include "ctrclient.h"
#include "types.h"
#include "utils.h"
#include "tmd.h"

#include "polarssl/aes.h"
#include "polarssl/sha2.h"

#define _FILE_OFFSET_BITS 64 /* for pre libcurl 7.19.0 curl_off_t magic */
#include <curl/curl.h>

int intitlekey_set = 0;
unsigned char intitlekey[16];
int titleversion_set = 0;
unsigned int titleversion = 0;

int dltitle = 0, dectitle = 0, disasm_title = 0;
int noromfs = 0;

int serveradr_set = 0;
char serveradr[256];

int tikdecrypt_titlekey(char *path, unsigned char *titlekey);

/********* Sample code generated by the curl command line tool **********
 * Lines with [REMARK] below might need to be modified to make this code 
 * usable. Add error code checking where appropriate.
 * Compile this with a suitable header include path. Then link with 
 * libcurl.
 * If you use any *_LARGE options, make sure your compiler figure
 * out the correct size for the curl_off_t variable.
 * Read the details for all curl_easy_setopt() options online on:
 * http://curlm.haxx.se/libcurl/c/curl_easy_setopt.html
 ************************************************************************/
int http_request(char *url, FILE *outfile)
{
  CURLcode ret;
  CURL *hnd = curl_easy_init();

  curl_easy_setopt(hnd, CURLOPT_INFILESIZE_LARGE, (curl_off_t)-1);
  curl_easy_setopt(hnd, CURLOPT_URL, url);
  curl_easy_setopt(hnd, CURLOPT_FILE, outfile);
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 0);
  curl_easy_setopt(hnd, CURLOPT_HEADER, 0);
  curl_easy_setopt(hnd, CURLOPT_FAILONERROR, 0);
  curl_easy_setopt(hnd, CURLOPT_DIRLISTONLY, 0);
  curl_easy_setopt(hnd, CURLOPT_APPEND, 0);
  curl_easy_setopt(hnd, CURLOPT_FOLLOWLOCATION, 0);
  curl_easy_setopt(hnd, CURLOPT_UNRESTRICTED_AUTH, 0);
  curl_easy_setopt(hnd, CURLOPT_TRANSFERTEXT, 0);
  curl_easy_setopt(hnd, CURLOPT_USERPWD, NULL);
  curl_easy_setopt(hnd, CURLOPT_RANGE, NULL);
  curl_easy_setopt(hnd, CURLOPT_TIMEOUT, 0);
  curl_easy_setopt(hnd, CURLOPT_LOW_SPEED_LIMIT, 0);
  curl_easy_setopt(hnd, CURLOPT_LOW_SPEED_TIME, 0);
  curl_easy_setopt(hnd, CURLOPT_MAX_SEND_SPEED_LARGE, (curl_off_t)0);
  curl_easy_setopt(hnd, CURLOPT_MAX_RECV_SPEED_LARGE, (curl_off_t)0);
  curl_easy_setopt(hnd, CURLOPT_RESUME_FROM_LARGE, (curl_off_t)0);
  curl_easy_setopt(hnd, CURLOPT_COOKIE, NULL);
  curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSLCERT, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSLCERTTYPE, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSLKEY, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSLKEYTYPE, NULL);
  curl_easy_setopt(hnd, CURLOPT_KEYPASSWD, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 2);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0);
  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 1);
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50);
  curl_easy_setopt(hnd, CURLOPT_CRLF, 0);
  curl_easy_setopt(hnd, CURLOPT_QUOTE, NULL);
  curl_easy_setopt(hnd, CURLOPT_POSTQUOTE, NULL);
  curl_easy_setopt(hnd, CURLOPT_PREQUOTE, NULL);
  curl_easy_setopt(hnd, CURLOPT_WRITEHEADER, NULL);
  curl_easy_setopt(hnd, CURLOPT_SSLVERSION, 3);
  curl_easy_setopt(hnd, CURLOPT_TIMECONDITION, 0);
  curl_easy_setopt(hnd, CURLOPT_TIMEVALUE, 0);
  curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, NULL);
  curl_easy_setopt(hnd, CURLOPT_HTTPPROXYTUNNEL, 0);
  curl_easy_setopt(hnd, CURLOPT_INTERFACE, NULL);
  curl_easy_setopt(hnd, CURLOPT_RANDOM_FILE, NULL);
  curl_easy_setopt(hnd, CURLOPT_CONNECTTIMEOUT, 0);
  curl_easy_setopt(hnd, CURLOPT_ENCODING, NULL);
  curl_easy_setopt(hnd, CURLOPT_POSTREDIR, 0);
  ret = curl_easy_perform(hnd);
  curl_easy_cleanup(hnd);
  return (int)ret;
}

ctr_tmd_body *tmd_get_body(unsigned char *tmdbuf) 
{
	unsigned int type = getbe32(tmdbuf);
	ctr_tmd_body *body = NULL;

	if (type == TMD_RSA_2048_SHA256 || type == TMD_RSA_2048_SHA1)
	{
		body = (ctr_tmd_body*)(tmdbuf + sizeof(ctr_tmd_header_2048));
	}
	else if (type == TMD_RSA_4096_SHA256 || type == TMD_RSA_4096_SHA1)
	{
		body = (ctr_tmd_body*)(tmdbuf + sizeof(ctr_tmd_header_4096));
	}

	return body;
}

int cdn_download(uint64_t titleid, char *titledir, char *name, char *path)
{
	int ret;
	FILE *f;
	struct stat filestat;
	char url[256];

	memset(url, 0, 256);

	if(path[0]==0)snprintf(path, 255, "%s/%s", titledir, name);
	snprintf(url, 255, "http://nus.cdn.c.shop.nintendowifi.net/ccs/download/%016"PRIx64"/%s", titleid, name);

	if(strcmp(name, "cetk") == 0)
	{
		if(stat(path, &filestat)==0)
		{
			printf("cetk already exists locally, skipping download for it.\n");
			return 0;
		}
	}

	f = fopen(path, "wb");
	if(f==NULL)
	{
		printf("Failed to open %s\n", path);
		return 1;
	}

	printf("Downloading %s to %s...\n", url, path);

	ret = http_request(url, f);
	fclose(f);

	return ret;
}

int download_contents(uint64_t titleid, char *titlepath, ctr_tmd_contentchunk *chunks, u16 total_contents)
{
	int ret;
	char path[256];
	char dlname[32];

	u16 index;
	u32 contentid;

	printf("Total contents: %x\n", total_contents);

	for(index=0; index<total_contents; index++)
	{
		contentid = getbe32(chunks[index].id);

		printf("Index %d:\n", index);
		printf("ContentID %08x\n\n", contentid);

		memset(path, 0, 256);
		memset(dlname, 0, 32);
		snprintf(dlname, 31, "%08x", contentid);

		ret = cdn_download(titleid, titlepath, dlname, path);
		if(ret!=0)
		{
			printf("Failed to download contentID %08x: %d", contentid, ret);
			return ret;
		}
	}

	return 0;
}

int decrypt_ncch(u32 contentid, char *titlepath)
{
	int ret;
	char sys_cmd[1024];
	char basepath[64];
	char noromfs_cmd[16];
	char serveradr_cmd[64];
	char disasm_cmd[64];

	memset(sys_cmd, 0, 1023);
	memset(basepath, 0, 64);
	memset(noromfs_cmd, 0, 16);
	memset(serveradr_cmd, 0, 64);
	memset(disasm_cmd, 0, 64);
	snprintf(basepath, 63, "%s/%08x", titlepath, contentid);
	if(noromfs)strncpy(noromfs_cmd, "--noromfs", 15);
	if(serveradr_set)snprintf(serveradr_cmd, 63, "--serveradr=%s", serveradr);
	if(disasm_title)snprintf(disasm_cmd, 63, "--disasm");

	snprintf(sys_cmd, 1023, "ctrclient-ncch --input=%s.app --output=%s.bin --ctrtoolprefix=%s %s %s %s", basepath, basepath, basepath, noromfs_cmd, serveradr_cmd, disasm_cmd);
	ret = system(sys_cmd);
	return ret;
}

int decrypt_contents(uint64_t titleid, char *titlepath, ctr_tmd_contentchunk *chunks, u16 total_contents)
{
	int ret;
	FILE *f;
	unsigned char *buffer;

	char path[256];
	char outpath[256];
	unsigned char titlekey[16];
	unsigned char iv[16];
	unsigned char calchash[32];
	aes_context aes_ctx;

	u16 index;
	u32 contentid;
	uint64_t contentsize;
	u32 contentsz_aligned;

	memset(titlekey, 0, 16);
	if(intitlekey_set)
	{
		memcpy(titlekey, intitlekey, 16);
		printf("Using input titlekey.\n");
	}
	else
	{
		memset(path, 0, 256);
		snprintf(path, 255, "%s/cetk", titlepath);
		ret = tikdecrypt_titlekey(path, titlekey);
		if(ret!=0)
		{
			printf("Failed to decrypt titlekey: %d\n", ret);
			return ret;
		}
	}

	ret = aes_setkey_dec(&aes_ctx, titlekey, 128);
	if(ret!=0)
	{
		printf("Failed to set key: %d\n", ret);
		return ret;
	}

	printf("Total contents: %x\n", total_contents);

	for(index=0; index<total_contents; index++)
	{
		contentid = getbe32(chunks[index].id);
		contentsize = getbe64(chunks[index].size);
		contentsz_aligned = ((u32)contentsize + 15) & ~15;

		printf("Index %d:\n", index);
		printf("ContentID: %08x\n", contentid);
		printf("Content Size: %016"PRIx64"\n", contentsize);

		memset(iv, 0, 16);
		memcpy(iv, chunks[index].index, 2);

		memset(path, 0, 256);
		memset(outpath, 0, 256);
		snprintf(path, 255, "%s/%08x", titlepath, contentid);
		snprintf(outpath, 255, "%s/%08x.app", titlepath, contentid);

		buffer = (unsigned char*)malloc(contentsz_aligned);
		if(buffer==NULL)
		{
			printf("Failed to alloc content buffer.\n");
			return 1;
		}
		memset(buffer, 0, contentsz_aligned);

		f = fopen(path, "rb");
		if(f==NULL)
		{
			printf("Failed to open %s for reading.\n", path);
			free(buffer);
			return 1;
		}

		if(fread(buffer, 1, contentsz_aligned, f) != contentsz_aligned)
		{
			printf("Failed to read content.\n");
			free(buffer);
			return 1;
		}
		fclose(f);

		ret = aes_crypt_cbc(&aes_ctx, AES_DECRYPT, (int)contentsz_aligned, iv, buffer, buffer);
		if(ret!=0)
		{
			printf("Failed to decrypt content: %d\n", ret);
			free(buffer);
			return ret;
		}

		f = fopen(outpath, "wb");
		if(f==NULL)
		{
			printf("Failed to open %s for writing.\n", outpath);
			free(buffer);
			return 1;
		}

		if(fwrite(buffer, 1, contentsz_aligned, f) != contentsz_aligned)
		{
			printf("Failed to write content.\n");
			free(buffer);
			return 1;
		}
		fclose(f);

		memset(calchash, 0, 32);
		sha2(buffer, (int)contentsize, calchash, 0);
		free(buffer);

		printf("Content hash: ");
		if(memcmp(chunks[index].hash, calchash, 32)==0)
		{
			printf("GOOD!\n");
		}
		else
		{
			printf("BAD!\n");
			printf("Aborting...\n");
			return 4;
		}
		printf("\n");
	}

	for(index=0; index<total_contents; index++)
	{
		contentid = getbe32(chunks[index].id);

		ret = decrypt_ncch(contentid, titlepath);
		if(ret!=0)
		{
			printf("Failed to decrypt contentID %08x NCCH.\n", contentid);
			return ret;
		}
	}

	return 0;
}

int parse_tmd(uint64_t titleid, char *titlepath)
{
	int ret = 0;
	unsigned char *tmdbuf;
	unsigned int tmdsz = 0;
	ctr_tmd_body *tmdbody = NULL;

	FILE *f;
	struct stat tmdstat;
	char path[256];

	memset(path, 0, 256);
	snprintf(path, 255, "%s/tmd", titlepath);

	if(stat(path, &tmdstat)==-1)
	{
		printf("Failed to stat %s\n", path);
		return 1;
	}

	tmdsz = tmdstat.st_size;
	tmdbuf = (unsigned char*)malloc(tmdsz);
	if(tmdbuf==NULL)
	{
		printf("Failed to alloc TMD buffer.\n");
		return 1;
	}
	memset(tmdbuf, 0, tmdsz);
	
	f = fopen(path, "rb");
	if(f==NULL)
	{
		printf("Failed to open %s\n", path);
		free(tmdbuf);
		return 1;
	}

	if(fread(tmdbuf, 1, tmdsz, f) != tmdsz)
	{
		printf("Failed to read TMD.\n");
		fclose(f);
		free(tmdbuf);
		return 1;
	}
	fclose(f);

	tmdbody = tmd_get_body(tmdbuf);
	if(tmdbody==NULL)
	{
		printf("Unknown type %x\n", getbe32(tmdbuf));
		free(tmdbuf);
		return 3;
	}

	if(tmdbody->version!=1)
	{
		printf("TMD version is %x, only version 1 is supported.\n", tmdbody->version);
		free(tmdbuf);
		return 3;
	}

	if(dltitle)
	{
		ret = download_contents(titleid, titlepath, (ctr_tmd_contentchunk*)(tmdbody->contentinfo + 36*64), getbe16(tmdbody->contentcount));
		if(ret!=0)
		{
			printf("Failed to download contents.\n");
			free(tmdbuf);
			return ret;
		}
	}

	if(dectitle)
	{
		ret = decrypt_contents(titleid, titlepath, (ctr_tmd_contentchunk*)(tmdbody->contentinfo + 36*64), getbe16(tmdbody->contentcount));
		if(ret!=0)printf("Failed to decrypt contents.\n");
	}

	free(tmdbuf);

	return ret;
}

int download_title(uint64_t titleid, char *titlepath)
{
	int ret;
	char path[256];
	char dlname[16];

	memset(path, 0, 256);
	memset(dlname, 0, 16);
	snprintf(path, 255, "%s/tmd", titlepath);
	if(!titleversion_set)strncpy(dlname, "tmd", 15);
	if(titleversion_set)snprintf(dlname, 15, "tmd.%u", titleversion);

	ret = cdn_download(titleid, titlepath, dlname, path);
	if(ret!=0)
	{
		printf("Failed to download TMD: %d\n", ret);
		return ret;
	}

	memset(path, 0, 256);
	ret = cdn_download(titleid, titlepath, "cetk", path);
	if(ret!=0)
	{
		printf("Failed to download ticket: %d\n", ret);
		return ret;
	}

	ret = parse_tmd(titleid, titlepath);
	if(ret!=0)
	{
		printf("Failed to download contents/parse tmd: %d\n", ret);
		return ret;
	}

	return 0;
}

int get_key(const char *name, uint8_t *key, uint32_t len)//based on the save_extract func
{
	char path[256];

	char *home = getenv("HOME");
	if (home == NULL)
	{
		return -1;
	}
	snprintf(path, sizeof(path), "%s/.3ds/%s", home, name);

	FILE *fp = fopen(path, "rb");
	if (fp == 0)
	{
		return -1;
	}

	if (fread(key, len, 1, fp) != 1)
	{
		fclose(fp);
		return -1;
	}
	fclose(fp);

	return 0;
}

int decrypt_titlekey(unsigned char *ticket, unsigned char *titlekey)
{
	ctrclient client;
	aes_context aes_ctx;

	unsigned char key[16];
	unsigned char iv[16];
	char keyname[16];

	unsigned char keyindex;
	int ret = 0;
	int normalkey = 0;

	memset(key, 0, 16);
	memcpy(titlekey, &ticket[0x1bf], 16);
	memset(iv, 0, 16);
	memcpy(iv, &ticket[0x1dc], 8);
	keyindex = ticket[0x1f1];

	printf("Using commonkey index %u\n", keyindex);

	memset(keyname, 0, 16);

	if(!normalkey)
	{
		snprintf(keyname, 15, "commonkeyY_%u", keyindex);
	}
	else
	{
		printf("Using dev commonkey\n");
		snprintf(keyname, 15, "common-key");
	}

	if(get_key(keyname, key, 16)!=0)
	{
		printf("Failed to load %s\n", keyname);
		return 1;
	}

	if(normalkey)
	{
		ret = aes_setkey_dec(&aes_ctx, key, 128);
		if(ret != 0)return 2;
	}
	else
	{
		ctrclient_init();
		if (0 == ctrclient_connect(&client, serveradr, "8333"))
			return 2;
		if (!ctrclient_aes_set_ykey(&client, 0x3d, key))
			return 2;
	}

	if(normalkey)
	{
		ret = aes_crypt_cbc(&aes_ctx, AES_DECRYPT, 16, iv, titlekey, titlekey);
		if(ret != 0)return 2;
	}
	else
	{
		if(!ctrclient_aes_set_iv(&client, iv))
			return 2;
		if(!ctrclient_aes_cbc_decrypt(&client, titlekey, 16))
			return 2;

		ctrclient_disconnect(&client);
	}

	return 0;
}

int tikdecrypt_titlekey(char *path, unsigned char *titlekey)
{
	int i, ret;
	FILE *ftik;
	unsigned char tikbuf[0x2a4];

	memset(tikbuf, 0, 0x2a4);
	memset(titlekey, 0, 16);

	ftik = fopen(path, "rb");
	if(ftik==NULL)
	{
		printf("Failed to open %s\n", path);
		return 1;
	}
	if(fread(tikbuf, 1, 0x2a4, ftik) != 0x2a4)
	{
		printf("Failed to read tik\n");

		fclose(ftik);
		return 1;
	}
	fclose(ftik);

	ret = decrypt_titlekey(tikbuf, titlekey);
	if(ret)return ret;

	printf("Encrypted titlekey: ");
	for(i=0; i<16; i++)printf("%02x", tikbuf[0x1bf + i]);
	printf("\nDecrypted titlekey: ");
	for(i=0; i<16; i++)printf("%02x", titlekey[i]);
	printf("\n");

	return 0;
}

int main(int argc, char *argv[])
{
	int ret;
	int argi, i, linei;
	int titleid_set = 0, found_start = 0;
	int pos;
	unsigned int tmp=0;
	int use_csv = 0;
	uint64_t titleid = 0;
	uint64_t begintitleid = 0;
	FILE *f;
	char *strptr;
	unsigned char titlekey[16];
	char titlepath[256];
	char titlepathtmp[256];
	char csvpath[256];
	char linebuf[1024];
	char region[8];

	if(argc==1)
	{
		printf("ctrclient-title by yellows8\n");
		printf("Decrypt a retail 3DS ticket and optionally title contents\n");
		printf("--serveradr=<addr> Server address to use.\n");
		printf("--tik=<path> Path to the ticket for decrypting the titlekey, this can be used multiple times to decrypt multiple tickets at once.\n");
		printf("--dltitle Download a 3DS title.\n");
		printf("--noromfs Pass the --noromfs option to ctrclient-ncch.\n");
		printf("--disasm Pass the --disasm option to ctrclient-ncch.\n");
		printf("--titleid=<titleID> TitleID for the title to process.\n");
		printf("--titlepath=<path> Directory for the downloaded title(s), and the directory for the encrypted/decrypted title(Default is current directory). This directory is automatically created.\n");
		printf("--titlever=<decimalver> Download the specified decimal title version.\n");
		printf("--decrypt=titlekey Decrypt the title stored in titledir, and use ctrclient-ncch to decrypt the NCCH contents. When '=<titlekey>' is specified, use the input titlekey to decrypt content instead of decrypting the tik titlekey.\n");
		printf("--csv=<csv_filepath> Parse the input CSV, for the operation(s) specified via the other parameters. When just --csv is used, the CSV is read from stdin. For example, to dl+decrypt titles for a sysupdate via the yls8.mtheall.com site: curl \"<URL for CSV>\" | ctrclient-title ... --dltitle --decrypt --titlepath=<sysupdate outdir> --csv\n");
		printf("--begintitle=<titleID> TitleID to begin download/decryption with, for the CSV.\n");
		return 0;
	}

	memset(serveradr, 0, 256);

	memset(intitlekey, 0, 16);
	memset(titlepath, 0, 256);
	memset(titlepathtmp, 0, 256);
	memset(csvpath, 0, 256);

	for(argi=1; argi<argc; argi++)
	{
		if(strncmp(argv[argi], "--serveradr=", 12)==0)
		{
			serveradr_set = 1;
			strncpy(serveradr, &argv[argi][12], 255);
		}

		if(strncmp(argv[argi], "--tik=", 6)==0)
		{
			tikdecrypt_titlekey(&argv[argi][6], titlekey);
		}

		if(strncmp(argv[argi], "--dltitle", 9)==0)
		{
			dltitle = 1;
		}
		if(strncmp(argv[argi], "--noromfs", 9)==0)
		{
			noromfs = 1;
		}
		if(strncmp(argv[argi], "--disasm", 8)==0)
		{
			disasm_title = 1;
		}

		if(strncmp(argv[argi], "--titleid=", 10)==0)
		{
			if(strlen(&argv[argi][10]) != 16)
			{
				printf("Invalid titleID.\n");
			}
			else
			{
				titleid_set = 1;
				sscanf(&argv[argi][10], "%016"PRIx64, &titleid);
			}
		}

		if(strncmp(argv[argi], "--titlepath=", 12)==0)strncpy(titlepath, &argv[argi][12], 255);

		if(strncmp(argv[argi], "--titlever=", 11)==0)
		{
			titleversion_set = 1;
			sscanf(&argv[argi][11], "%u", &titleversion);
		}

		if(strncmp(argv[argi], "--decrypt", 9)==0)
		{
			dectitle = 1;
			if(strlen(argv[argi]) == 10+32)
			{
				for(i=0; i<16; i++)
				{
					sscanf(&argv[argi][10 + i*2], "%02x", &tmp);
					intitlekey[i] = tmp;
				}

				intitlekey_set = 1;
			}
		}

		if(strncmp(argv[argi], "--csv", 5)==0)
		{
			use_csv = 1;
			if(argv[argi][5] == '=')strncpy(csvpath, &argv[argi][6], 255);
		}

		if(strncmp(argv[argi], "--begintitle=", 13)==0)
		{
			if(strlen(&argv[argi][13]) != 16)
			{
				printf("Invalid titleID.\n");
			}
			else
			{
				sscanf(&argv[argi][13], "%016"PRIx64, &begintitleid);
			}
		}
	}

	if(serveradr[0]==0)return 0;

	if(titleid_set==0 && !use_csv)return 0;

	if(titlepath[0]==0)
	{
		titlepath[0] = '.';
	}
	else
	{
		makedir(titlepath);
	}

	if(!use_csv)
	{
		if(dltitle)
		{
			ret = download_title(titleid, titlepath);
			return ret;
		}
		else if(dectitle)
		{
			ret = parse_tmd(titleid, titlepath);
			return ret;
		}
	}

	if(csvpath[0])
	{
		f = fopen(csvpath, "r");
		if(f==NULL)
		{
			printf("Failed to open CSV.\n");
			return 1;
		}
	}
	else
	{
		f = stdin;
	}

	found_start = 0;
	titleversion_set = 1;
	linei = 0;
	memset(linebuf, 0, 1024);

	if(!begintitleid)found_start = 1;

	while(fgets(linebuf, 1023, f))
	{
		strptr = strchr(linebuf, '\n');
		if(strptr)*strptr = 0;

		if(linei)//This assumes that the CSV has this format: TitleID,Region,Title version<,...>
		{
			//printf("Line: %s\n", linebuf);

			strptr = strtok(linebuf, ",");//TID
			sscanf(strptr, "%016"PRIx64, &titleid);

			if((begintitleid && !found_start) && titleid==begintitleid)
			{
				found_start = 1;
			}

			if(!found_start)continue;

			strptr = strtok(NULL, ",");//region
			memset(region, 0, 8);
			strncpy(region, strptr, 7);

			strptr = strtok(NULL, ",");//title-version
			if(strptr[0] == 'v')strptr++;
			sscanf(strptr, "%u", &titleversion);

			memset(titlepathtmp, 0, 256);
			snprintf(titlepathtmp, 255, "%s/%016"PRIx64, titlepath, titleid);
			makedir(titlepathtmp);

			pos = strlen(titlepathtmp);
			snprintf(&titlepathtmp[pos], 255 - pos, "/%s", region);
			makedir(titlepathtmp);

			pos = strlen(titlepathtmp);
			snprintf(&titlepathtmp[pos], 255 - pos, "/v%u", titleversion);
			makedir(titlepathtmp);

			printf("titleID: %016"PRIx64" region: %s titlever: %u. path: %s\n", titleid, region, titleversion, titlepathtmp);

			if(dltitle)
			{
				ret = download_title(titleid, titlepathtmp);
				if(ret!=0)return ret;
			}
			else if(dectitle)
			{
				ret = parse_tmd(titleid, titlepathtmp);
				if(ret!=0)return ret;
			}
		}

		linei++;
		memset(linebuf, 0, 1024);
	}

	if(csvpath[0])fclose(f);

    	return 0;
}

